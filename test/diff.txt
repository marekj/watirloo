diff --git a/lib/watirloo/watir_ducktape.rb b/lib/watirloo/watir_ducktape.rb
index e27732f..d094ec4 100644
--- a/lib/watirloo/watir_ducktape.rb
+++ b/lib/watirloo/watir_ducktape.rb
@@ -20,7 +20,7 @@ module Watir
     # sets Radio||Checkbox in a group by either position in a group or by hidden value attribute 
     def set(what)
       if what.kind_of?(Array)
-        what.each {|el| set el } #calls itself with Fixnum or String
+        what.each {|item| set item } #calls itself with Fixnum or String
       else
         if what.kind_of?(Fixnum)
           get_by_position(what).set
@@ -74,18 +74,29 @@ module Watir
       @o = @container.radios.find_all {|r| r.name == @name}
     end
     
-    # which value is selected?
+    # which value is selected?. returns value text as string
     def selected_value
       selected_radio.ole_object.invoke('value')
     end
     
+    # Only one radio in RadioGroup can be selected just like
+    # only one option in single select list box can be selected.
+    # this method is a bit gratuitious because it will always return array
+    # with one item
+    def selected_values
+      selected_value.to_a
+    end
+    
+    # in the absence of visible text like in select list we treat value
+    # as a selected text invisible to the user
+    alias selected selected_value
+    
     # returns radio that is selected.
     # there can only be one radio selected. 
     # in the event that none is selected it returns nil
     def selected_radio
       @o.find {|r| r.isSet?}
     end
-    alias selected selected_radio
     
   end
   
@@ -108,7 +119,6 @@ module Watir
     def selected_checkboxes
       @o.select {|cb| cb.isSet?}
     end
-    alias selected selected_checkboxes
     
     def selected_values
       values = []
@@ -118,6 +128,26 @@ module Watir
       return values
     end
     
+    # convinience method as a filter for select_values
+    # returns: 
+    # nil for nothing selected. 
+    # single value if only once selected or just
+    # or returns selected_values
+    def selected_value
+      arr = selected_values
+      case arr.size
+      when 0 then nil
+      when 1 then arr[0]
+      else arr      
+      end
+    end
+    
+    # in case of checkbox there are no visible text items. 
+    # We rely on value attributes that must be present 
+    # to differentiate the checkbox in a group
+    alias selected selected_value
+     
+    
   end
 
   
@@ -135,13 +165,18 @@ module Watir
     alias set? isSet?
   end
   
-  # There are two kinds of SelectLists. singleselect and multi select
-  # select list presents user with visible items to select from.
+  # SelectList acts like RadioGroup or CheckboxGroup
+  # They all have options to select
+  # There are two kinds of SelectLists. SingleSelect and MultiSelect
+  # SelectList presents user with visible items to select from.
   # Each Item has a visible :text and invisible :value attributes
+  # (sometimes :value attributes are missing)
+  # 
   # In Watirloo
-  # The invisible :value attribute text we call option
-  # The visible :text we call :item
-  # The selected item we call :value
+  # The invisible :values attributes  we call :values
+  # The visible :text we call :items or options, contents (as secondary choice)
+  # The selected items as visible text we call :selected
+  # The selected items as values  we call :selected_values
   # 
   # example of single select list
   # 
@@ -151,58 +186,114 @@ module Watir
   #     <option value="opt2" selected>item2</option>
   #   </select> 
   #   
-  # items => ['', 'item1', 'item2']
-  # options => ['opt0','opt1', 'opt2']
-  # value => 'item2'
-  # 
+  #   items => ['', 'item1', 'item2']
+  #   values => ['opt0','opt1', 'opt2']
+  #   selected => ['item2']
+  #   selected_values => ['opt2']
+  #    
   # example of multi select list
+  # 
   #   <select name="controlname" multiple size=2>
   #     <option value="o1">item1
   #     <option value="o2" selected>item2
   #     <option value="o3" selected>item3
   #   </select>
-  # items => ['item1', 'item2', 'item3']
-  # options => ['o1','o2','o3']
-  # value => ['item2', 'item3'] # array of selected items by text
-  #
+  #   
+  #   items => ['item1', 'item2', 'item3']
+  #   values => ['o1','o2','o3']
+  #   selected => ['item2', 'item3']
+  #   selected_values => ['o2', 'o3']
+  # 
   class SelectList
     
-    # value returns the selected text item or items.
-    # either empty string for nothing selected.
-    # string if there is one value selected
-    # or array of values selected in multiselect list
-    # example select_list.value = '' # => select list has item with text '' selected or multiselect list has no values set
-    def value
-      a = getSelectedItems
-      return case a.size #TODO find if nil is better than empty string
-      when 0 then ''
-      when 1 then a[0]
-      else a
+    # For single select items selected returns array with one element.
+    # this is how Watir behaves it does not distinguish between single and multi
+    # selected_item is a convenience filter for selected_items
+    # returns: 
+    # nil if nothing is selected
+    # item text if one item selected
+    # or array from selected_items
+    def selected_item
+      arr = getSelectedItems
+      case arr.size
+      when 0 then nil
+      when 1 then arr[0]
+      else arr
       end
     end
     
+    alias selected_items getSelectedItems
+    alias selected selected_item
+    
     # accepts one text item or array of text items. if array then sets one after another. 
     # For single select lists the last item in array wins
     def set(item)
       if item.kind_of? Array
-        item.each do |single_item|
-          select_item_in_select_list(:text, single_item)
-        end
+        item.each { |single_item| set single_item} # call self with individual item
       else
-        select_item_in_select_list(:text, item)
+        if item.kind_of? Fixnum
+          if (0..items.size).member? item
+            set items[item-1]
+          else
+            raise ::Watir::Exception::WatirException, "number #{item} is out of range of item count"
+          end 
+        else
+          select_item_in_select_list(:text, item)  #finally
+        end
       end
     end
     
-    # each option may have a value attribute which is hidden to the person viewing the  page
-    def hidden_values
+    # make item be selected matching its hidden value attribute
+    def set_value(value)
+      if value.kind_of? Array
+        value.each {|single_value| set_value single_value}
+      else
+        select_item_in_select_list(:value, value)end
+    end
+        
+    # each option usually has a value attribute which is hidden to the person viewing the page
+    def values
       a = []
       attribute_value('options').each do |item|
         a << item.value
       end
       return a
     end
+
+    # like selected_items but returns array as values
+    def selected_values
+      assert_exists
+      arr = []
+      @o.each do |thisItem|
+        if thisItem.selected
+          arr << thisItem.value
+        end
+      end
+      return arr
+    end
+    
+    # convinience method as a filter for select_values
+    # returns: 
+    # nil for nothing selected. 
+    # single value if only once selected or just
+    # or returns selected_values
+    def selected_value
+      arr = selected_values
+      case arr.size
+      when 0 then nil
+      when 1 then arr[0]
+      else arr      
+      end
+    end
     
     alias clear clearSelection
+    
+    # alias, items or contents return the same visible text items
     alias items getAllContents
+    # alias, items or contents return the same visible text items
+    alias options getAllContents
+    # alias, items or contents return the same visible text items
+    alias contents getAllContents
+    
   end
 end
\ No newline at end of file
diff --git a/test/html/select_lists.html b/test/html/select_lists.html
index a153367..59e2416 100644
--- a/test/html/select_lists.html
+++ b/test/html/select_lists.html
@@ -25,7 +25,7 @@
         <option value="f">F</option>
       </select> 
 
-      <h3>single select with no hidden values</h3>
+      <h3>single select with no hidden values in options</h3>
       <p>if value attribute is not set <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-OPTGROUP">
       the initial value is set to the contents of the option element.</a></p>
       <select name="bubel">
diff --git a/test/radio_group_test.rb b/test/radio_group_test.rb
index 220ed55..49f6c49 100644
--- a/test/radio_group_test.rb
+++ b/test/radio_group_test.rb
@@ -1,29 +1,29 @@
+ar = ['a', 'b', 'c', 'd']
+#ar =[]
+#ar = ['a']
+
+v = case ar.size
+when 0 then nil
+when 1 then ar[0]
+else ar
+end
+
+puts v.inspect
+exit
+
+
+
+
 require File.dirname(__FILE__) + '/test_helper'
 
 class RadioGroupPage < Watirloo::Page
-  # array of radios sharing the same name
-  # the following works on IE but not on firefox    
-  # @b.radios.find_all {|r| r.name == 'food'} 
-  # find_all is undefined for radios method
-  # the solution is to do radios.each implementation
-  # returns array of radios sharing the same name
-  def food
-    o = []
-    @b.radios.each do |r|
-      if r.name == 'food'
-        o << r
-      end
-    end
-    return o
-  end
-
-  # RadioGroup Class (yes, collection of radios sharing the same name but as class)
-  def food_group
+  # RadioGroup Class refers to collection of radios sharing the same name
+  def meals_to_go
     @b.radio_group('food')
   end
 end
 
-describe 'food_group as RadioGroup class' do
+describe 'RadioGroup object on a page' do
 
   before do
     @page = RadioGroupPage.new
@@ -31,50 +31,56 @@ describe 'food_group as RadioGroup class' do
   end
   
   it 'container radio_group method returns RadioGroup class' do
+    # verify browser namespace explicitly
     if @page.b.kind_of?(FireWatir::Firefox)
-      @page.food_group.kind_of?(FireWatir::RadioGroup).should.be true
+      @page.meals_to_go.kind_of?(FireWatir::RadioGroup).should.be true
       
     elsif @page.b.kind_of?(Watir::IE)
-      @page.food_group.kind_of?(Watir::RadioGroup).should.be true
+      @page.meals_to_go.kind_of?(Watir::RadioGroup).should.be true
     end
   end
   
   it 'size or count returns how many radios in a group' do
-    @page.food_group.size.should == 3
-    @page.food_group.count.should == 3
+    @page.meals_to_go.size.should == 3
+    @page.meals_to_go.count.should == 3
   end
   
   it 'values returns value attributes text items as an array' do
-    @page.food_group.values.should == ["hotdog", "burger", "tofu"]
+    @page.meals_to_go.values.should == ["hotdog", "burger", "tofu"]
   end
   
   it 'selected_value returns internal option value for selected radio item in a group' do 
-    @page.food_group.selected_value.should == 'burger'
+    @page.meals_to_go.selected_value.should == 'burger'
+    @page.meals_to_go.selected_values.should == ['burger'] # matches select_list api
   end
   
   it 'set selects radio by position in a group' do
-    @page.food_group.set 3
-    @page.food_group.selected_value.should == 'tofu'
-    @page.food_group.set 1
-    @page.food_group.selected_value.should == 'hotdog'
+    @page.meals_to_go.set 3
+    @page.meals_to_go.selected_value.should == 'tofu'
+    @page.meals_to_go.selected_values.should == ['tofu']
+
+    @page.meals_to_go.set 1
+    @page.meals_to_go.selected_value.should == 'hotdog'
+    @page.meals_to_go.selected_values.should == ['hotdog']
   end
   
   it 'set selects radio by value in a group' do
-    @page.food_group.set 'hotdog'
-    @page.food_group.selected_value.should == 'hotdog'
-    @page.food_group.set 'tofu'
-    @page.food_group.selected_value.should == 'tofu'
+    @page.meals_to_go.set 'hotdog'
+    @page.meals_to_go.selected_value.should == 'hotdog'
+
+    @page.meals_to_go.set 'tofu'
+    @page.meals_to_go.selected_value.should == 'tofu'
   end
   
   it 'set position throws exception if number not within the range of group size' do
     assert_raise(Watir::Exception::WatirException) do
-      @page.food_group.set 7
+      @page.meals_to_go.set 7
     end
   end
   
   it 'set value throws exception if value not found in options' do
     assert_raise(Watir::Exception::WatirException) do
-      @page.food_group.set 'banannnanna'
+      @page.meals_to_go.set 'banannnanna'
     end
   end
   
@@ -82,7 +88,7 @@ describe 'food_group as RadioGroup class' do
   # to actual values here in the radio_group or at the Watirllo level only? 
   it 'set throws exception if other than Fixnum or String element is used' do
     assert_raise(Watir::Exception::WatirException)do
-      @page.food_group.set :yes
+      @page.meals_to_go.set :yes
     end
   end
   
diff --git a/test/select_list_as_face_test.rb b/test/select_list_as_face_test.rb
index ac6e16f..ac01476 100644
--- a/test/select_list_as_face_test.rb
+++ b/test/select_list_as_face_test.rb
@@ -10,7 +10,7 @@ describe "select list as semantic face object on a page" do
       :gender => [:select_list, :name, 'sex_cd'])
   end
   
-  it 'face method with key parameter to construct SelectList' do
+  it 'face method with key parameter to construct SelectList per browser implementation' do
     if @page.b.kind_of?(FireWatir::Firefox)
       @page.face(:pets).kind_of?(FireWatir::SelectList).should == true
       @page.face(:gender).kind_of?(FireWatir::SelectList).should == true
@@ -21,7 +21,18 @@ describe "select list as semantic face object on a page" do
     end
   end
   
-  it 'face key as method matching modeling semantic object accessor' do
+  it 'face(:facename) and browser.select_list implementation return the same thing' do
+    @page.b.select_list(:name, 'sex_cd').should == @page.gender
+    @page.b.select_list(:name, 'animals').should == @page.pets
+  end
+  
+  
+  it 'face(:facename) and facename return the same object' do
+    @page.face(:gender).should == @page.gender
+    @page.face(:pets).should == @page.pets
+  end
+
+  it 'facename method matching modeling semantic object accessor' do
     if @page.b.kind_of?(FireWatir::Firefox)
       @page.pets.kind_of?(FireWatir::SelectList).should == true
       @page.gender.kind_of?(FireWatir::SelectList).should == true
diff --git a/test/select_list_options_test.rb b/test/select_list_options_test.rb
index a3a2de5..e9bf7cb 100644
--- a/test/select_list_options_test.rb
+++ b/test/select_list_options_test.rb
@@ -1,6 +1,6 @@
 require File.dirname(__FILE__) + '/test_helper'
 
-describe "select list page objects options as actual values not visible to the user" do
+describe "select list options as visible items and values as hidden to the user attributes" do
   
   before do
     @page = Watirloo::Page.new
@@ -10,27 +10,35 @@ describe "select list page objects options as actual values not visible to the u
       :gender => [:select_list, :name, 'sex_cd'],
       :toys => [:select_list, :name, 'bubel'])
   end
-
-  it 'options by face key method' do
-    @page.face(:gender).hidden_values.should == ['', 'm', 'f']
-    @page.face(:pets).hidden_values.should == ['o1', 'o2', 'o3', 'o4', 'o5']
+  
+  it 'values of options by face(:facename) method' do
+    @page.face(:gender).values.should == ['', 'm', 'f']
+    @page.face(:pets).values.should == ['o1', 'o2', 'o3', 'o4', 'o5']
   end
   
-  it 'options by method name matching face key' do
-    @page.gender.hidden_values.should == ['', 'm', 'f']
-    @page.pets.hidden_values.should == ['o1', 'o2', 'o3', 'o4', 'o5']
+  it 'values of options by facename method' do
+    @page.gender.values.should == ['', 'm', 'f']
+    @page.pets.values.should == ['o1', 'o2', 'o3', 'o4', 'o5']
   end
   
   it 'options with no value attribute' do
     # in case of IE it will return all blanks
-    @page.toys.hidden_values.should == ["", "", "", "", ""]
-    # for Firfox it returns actual items ["", "foobel", "barbel", "bazbel", "chuchu"]
-    # known failure on Firefox
+    if @page.b.kind_of?(Watir::IE)
+      @page.toys.values.should == ["", "", "", "", ""]
+    elsif @page.b.kind_of?(FireWatir::Firefox)
+      @page.toys.values.should == ["", "foobel", "barbel", "bazbel", "chuchu"]
+      # for Firfox it returns actual items 
+    end
   end
   
-  it 'options with no value attribute return items' do
+  it 'options method returns visible contents as array of text items' do
     @page.toys.items.should == ["", "foobel", "barbel", "bazbel", "chuchu"]
   end
   
+  it 'options returns visible text items as array' do
+    @page.pets.items.should == ['cat', 'dog', 'zook', 'zebra', 'wumpa']
+    @page.gender.items.should == ["", "M", "F"]
+  end
+  
   
 end
\ No newline at end of file
diff --git a/test/select_lists_test.rb b/test/select_lists_test.rb
index 6a80a5a..5163100 100644
--- a/test/select_lists_test.rb
+++ b/test/select_lists_test.rb
@@ -1,6 +1,6 @@
 require File.dirname(__FILE__) + '/test_helper'
 
-describe "select list as semantic face object on a page" do
+describe "select list as semantic face name object on a page" do
   
   before do
     @page = Watirloo::Page.new
@@ -10,53 +10,67 @@ describe "select list as semantic face object on a page" do
       :gender => [:select_list, :name, 'sex_cd'])
   end
   
-  it 'semantic value is the selected text visible to the user. when nothing selected value should be blank string' do
-    @page.pets.value.should == ''
-    @page.gender.value.should == ''
+  it 'selected returns preselected items' do
+    @page.gender.selected.should == '' # in single select "" is preselected
+    @page.pets.selected.should == nil # in multiselect noting is selected
   end
   
-  it 'semantic value is the selected text. after setting one item select the value should be a string that was set' do
+  it 'set item text. selected returns visible text items' do
     @page.pets.set 'dog'
-    @page.pets.value.should == 'dog'
+    @page.pets.selected.should == 'dog' #multi select one item selected
+
     @page.gender.set 'F'
-    @page.gender.value.should == 'F'
+    @page.gender.selected.should == 'F' # single select one item of course
   end
+  
 
-  it 'semantic value is the selected text. setting multiple items the value is an array of strings' do
+  it 'set items array for multiselect selects each one item. selected returns items that were set' do
     @page.pets.set ['cat', 'dog']
-    @page.pets.value.should == ['cat','dog']
+    @page.pets.selected.should == ['cat','dog']
   end
 
-  it 'setting multiple items for single select selects one in turn and value is the last item in array' do
+   # this is not practical for single select but can be done for testing 
+   # conditions arising from switching itesm in a batch approach
+  it 'set items array for single select selects each in turn. selected is the last item in array' do
     @page.gender.set ['M', 'F', '','F']
-    @page.gender.value.should == 'F'
+    @page.gender.selected.should == 'F'
   end
   
-  it 'setting single item after multiple items were set returns all values set for multiselect as array of strings' do
+  it 'set item after multiple items were set returns all values selected for multiselect' do
     @page.pets.set ['cat','zook']
     @page.pets.set 'zebra'
-    @page.pets.value.should == ['cat', 'zook', 'zebra']
+    @page.pets.selected.should == ['cat', 'zook', 'zebra']
   end
   
   it 'clear methods deselects clears all selected items in multiselect' do
-    @page.pets.set ['cat','zook']
+    @page.pets.selected.should == nil
+    @page.pets.set ['zook', 'cat']
+    @page.pets.selected.should == ['cat','zook']
     @page.pets.clear
-    @page.pets.value.should == ''
+    @page.pets.selected.should == nil
   end
 
   it 'clear method removes selected attribute for item in single select list' do
+    @page.gender.selected.should == ''
     @page.gender.set 'F'
-    @page.gender.value.should == 'F'
+    @page.gender.selected.should == 'F'
     @page.gender.clear
-    @page.gender.value.should == '' # This fails on IE. it does not remove selected attribute from option
+    @page.gender.selected.should == '' # This fails on IE. it does not remove selected attribute from option
   end
   
-  it 'user can select by option value using watir methods' do
+  it 'set_value selects value atribute text' do
     @page.gender.select_value 'm'
-    @page.gender.value.should == 'M'
+    @page.gender.selected.should == 'M'
+    @page.gender.selected_value.should == 'm'
+  end
+  
+  it 'set_value for multiselect returns selected and selected_values' do
     @page.pets.select_value 'o2'
     @page.pets.select_value 'o4'
-    @page.pets.value.should == ['dog', 'zebra']
+    @page.pets.selected.should == ['dog', 'zebra']
+    @page.pets.selected_values.should == ['o2', 'o4']
   end
   
+  
+  
 end
